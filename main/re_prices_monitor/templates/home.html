{% extends 'base.html' %}

{% block content %}
<!-- {% load static %} -->

<div class="App">

    <header class="App-header">
        <img src="{% static 'images/django-logo.png' %}" class="App-logo" alt="logo" />
        <h3>Welcome in Real Estate Prices Monitor Application</h3>
    </header>

    <section class="Section-Box">
        <form method="post" class="Select-Menus-Box" onchange="submit()">
            {% csrf_token %}

            <div class="Single-Select-Box">
                <h4> {{ form.city.label_tag }} </h4>
                {{ form.city }}
            </div>
            <div class="Single-Select-Box">
                <h4> {{ form.market.label_tag }} </h4>
                {{ form.market }}
            </div>
            <div class="Single-Select-Box">
                <h4> {{ form.data_type.label_tag }} </h4>
                {{ form.data_type }}
            </div>
            <!-- <button type="submit" class="btn btn-primary">Submit</button> -->
        </form>
    </section>

    
    <section class="Section-Box">
        <h4>Average Prices Trend</h4>
        <canvas id="Price-Trend-Chart" width="400" height="200"></canvas>
    </section>


    <section class="Section-Box">
        <div id="inputSections"></div>  
        <button onclick="addInputSection()">Add Select Section</button>

        <div id="scatterPlot" style="width: 100%; height: 100vh;"></div>
        <!-- <div id="selectedHistogram" style="width: 100%; height: 50vh;"></div> -->
    </section>


    <section class="Section-Box">
        <h4>Average prices and informations from last scraping</h4>
        <table class='table table-striped table-bordered table-hover'>
            <thead>
                <tr>
                    <th>Pos.</th>
                    <th>Data</th>
                    <th>City</th>
                    <th>Market</th>
                    <th>Price m2</th>               
                    <th>Total price</th>
                    <th>Rooms</th>
                    <th>Area</th>
                </tr>
            </thead>
            <tbody>
                {% for offer in latest_offers %}
                    <tr>
                        <td>{{ forloop.counter }}</td>
                        <td>{{ offer.date }}</td>
                        <td>{{ offer.city_name }}</td>
                        <td>{{ offer.market_type }}</td>
                        <td>{{ offer.m2_price }}</td>
                        <td>{{ offer.total_price }}</td>
                        <td>{{ offer.rooms }}</td>
                        <td>{{ offer.area }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    </section>


</div>

<!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>

    const data = JSON.parse('{{ chart_data|safe|escapejs }}');

    let ctx = document.getElementById("Price-Trend-Chart").getContext("2d");

    let chart = new Chart(ctx, {
    type: "line",
    data: data.data,
    
    });


</script> -->


<script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.8/dist/echarts-gl.min.js"></script>




<!-- <script>
    // Funkcja do generowania losowych danych dla wykresu scatter
    function generateScatterData(numPoints) {
        const data = [];
        for (let i = 0; i < numPoints; i++) {
            const x_value = Math.random() * 100;
            const y_value = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
            data.push([x_value, y_value]);
        }
        return data;
    }

    // Funkcja do agregacji danych
    function aggregateData(data, gridSize) {
        const grid = {};
        data.forEach(point => {
            const x = Math.floor(point[0] / gridSize);
            const y = Math.floor(point[1] / gridSize);
            const key = `${x},${y}`;
            if (!grid[key]) {
                grid[key] = { count: 0, sumX: 0, sumY: 0 };
            }
            grid[key].count++;
            grid[key].sumX += point[0];
            grid[key].sumY += point[1];
        });
        const aggregatedData = [];
        for (const key in grid) {
            const cell = grid[key];
            aggregatedData.push([cell.sumX / cell.count, cell.sumY / cell.count, cell.count]);
        }
        return aggregatedData;
    }

    // Generowanie danych dla wykresu scatter
    const numPoints = 1000000; // Milion punktów
    const scatterData = generateScatterData(numPoints);

    // Agregacja danych
    const gridSize = 1; // Rozmiar komórki siatki
    const aggregatedData = aggregateData(scatterData, gridSize);

    // Inicjalizacja wykresu scatter
    const chartDom = document.getElementById('scatterPlot');
    const myChart = echarts.init(chartDom);
    const option = {
        title: {
            text: 'Aggregated Scatter Plot with 1 Million Points'
        },
        tooltip: {
            trigger: 'item',
            formatter: function (params) {
                return `X: ${params.value[0]}, Y: ${params.value[1]}, Count: ${params.value[2]}`;
            }
        },
        xAxis: {
            type: 'value',
            name: 'X Axis'
        },
        yAxis: {
            type: 'value',
            name: 'Y Axis'
        },
        series: [{
            type: 'scatter',
            symbolSize: function (val) {
                return Math.sqrt(val[2]); // Rozmiar punktu zależny od liczby punktów w komórce
            },
            data: aggregatedData,
            itemStyle: {
                color: 'blue'
            }
        }],
        dataZoom: [
            {
                type: 'inside',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'inside',
                yAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                yAxisIndex: 0,
                start: 0,
                end: 100
            }
        ],
        brush: {
            toolbox: ['rect', 'polygon', 'keep', 'clear'],
            xAxisIndex: 0,
            yAxisIndex: 0
        }
    };

    // Renderowanie wykresu scatter
    myChart.setOption(option);

    // Inicjalizacja wykresu histogram dla zaznaczonego obszaru
    const selectedChartDom = document.getElementById('selectedHistogram');
    const selectedChart = echarts.init(selectedChartDom);
    const selectedOption = {
        title: {
            text: 'Histogram of Selected Area'
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            }
        },
        xAxis: {
            type: 'category',
            name: 'Value',
            data: []
        },
        yAxis: {
            type: 'value',
            name: 'Frequency'
        },
        series: [{
            type: 'bar',
            data: []
        }]
    };

    // Renderowanie pustego wykresu histogram
    selectedChart.setOption(selectedOption);

    // Funkcja do obliczania histogramu
    function calculateHistogram(data, binCount) {
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binSize = (max - min) / binCount;
        const bins = Array(binCount).fill(0);
        data.forEach(value => {
            const binIndex = Math.min(Math.floor((value - min) / binSize), binCount - 1);
            bins[binIndex]++;
        });
        const binEdges = Array.from({ length: binCount }, (_, i) => (min + i * binSize).toFixed(2));
        return { bins, binEdges };
    }

    // Obsługa zdarzenia brushSelected
    myChart.on('brushSelected', function (params) {
        const selectedData = [];
        const mainSeries = params.batch[0].selected[0];
        for (let i = 0; i < mainSeries.dataIndex.length; i++) {
            selectedData.push(scatterData[mainSeries.dataIndex[i]][0]); // Używamy wartości X do histogramu
        }

        // Oblicz histogram
        const binCount = 20; // Liczba koszyków
        const histogram = calculateHistogram(selectedData, binCount);

        // Aktualizacja wykresu histogram
        selectedChart.setOption({
            xAxis: {
                data: histogram.binEdges
            },
            series: [{
                data: histogram.bins
            }]
        });
    });
</script> -->



<!-- <script>
    // Funkcja do generowania losowych danych dla wykresu scatter
    function generateScatterData(numPoints, startIndex = 0) {
        const data = [];
        for (let i = startIndex; i < startIndex + numPoints; i++) {
            const x_value = Math.random() * 100;
            const y_value = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
            data.push([x_value, y_value]);
        }
        return data;
    }

    // Generowanie początkowej partii danych dla wykresu scatter
    const totalPoints = 1000000; // Milion punktów
    const batchSize = 100000; // Wielkość partii
    let loadedPoints = 0;
    let scatterData = generateScatterData(batchSize, loadedPoints);
    loadedPoints += batchSize;

    // Inicjalizacja wykresu scatter
    const chartDom = document.getElementById('scatterPlot');
    const myChart = echarts.init(chartDom);
    const option = {
        title: {
            text: 'Scatter Plot with Lazy Loading'
        },
        tooltip: {
            trigger: 'item',
            formatter: function (params) {
                return `X: ${params.value[0]}, Y: ${params.value[1]}`;
            }
        },
        xAxis: {
            type: 'value',
            name: 'X Axis'
        },
        yAxis: {
            type: 'value',
            name: 'Y Axis'
        },
        series: [{
            type: 'scatter',
            symbolSize: 2,
            data: scatterData,
            itemStyle: {
                color: 'blue'
            }
        }],
        dataZoom: [
            {
                type: 'inside',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'inside',
                yAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                yAxisIndex: 0,
                start: 0,
                end: 100
            }
        ],
        brush: {
            toolbox: ['rect', 'polygon', 'keep', 'clear'],
            xAxisIndex: 0,
            yAxisIndex: 0
        }
    };

    // Renderowanie wykresu scatter
    myChart.setOption(option);

    // Funkcja do ładowania kolejnej partii danych
    function loadMoreData() {
        if (loadedPoints < totalPoints) {
            const newData = generateScatterData(batchSize, loadedPoints);
            scatterData = scatterData.concat(newData);
            loadedPoints += batchSize;
            myChart.setOption({
                series: [{
                    data: scatterData
                }]
            });
        }
    }

    // Ładowanie kolejnych partii danych przy przewijaniu
    myChart.on('dataZoom', function () {
        loadMoreData();
    });

    // Inicjalizacja wykresu histogram dla zaznaczonego obszaru
    const selectedChartDom = document.getElementById('selectedHistogram');
    const selectedChart = echarts.init(selectedChartDom);
    const selectedOption = {
        title: {
            text: 'Histogram of Selected Area'
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            }
        },
        xAxis: {
            type: 'category',
            name: 'Value',
            data: []
        },
        yAxis: {
            type: 'value',
            name: 'Frequency'
        },
        series: [{
            type: 'bar',
            data: []
        }]
    };

    // Renderowanie pustego wykresu histogram
    selectedChart.setOption(selectedOption);

    // Funkcja do obliczania histogramu
    function calculateHistogram(data, binCount) {
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binSize = (max - min) / binCount;
        const bins = Array(binCount).fill(0);
        data.forEach(value => {
            const binIndex = Math.min(Math.floor((value - min) / binSize), binCount - 1);
            bins[binIndex]++;
        });
        const binEdges = Array.from({ length: binCount }, (_, i) => (min + i * binSize).toFixed(2));
        return { bins, binEdges };
    }

    // Obsługa zdarzenia brushSelected
    myChart.on('brushSelected', function (params) {
        const selectedData = [];
        const mainSeries = params.batch[0].selected[0];
        for (let i = 0; i < mainSeries.dataIndex.length; i++) {
            selectedData.push(scatterData[mainSeries.dataIndex[i]][0]); // Używamy wartości X do histogramu
        }

        // Oblicz histogram
        const binCount = 20; // Liczba koszyków
        const histogram = calculateHistogram(selectedData, binCount);

        // Aktualizacja wykresu histogram
        selectedChart.setOption({
            xAxis: {
                data: histogram.binEdges
            },
            series: [{
                data: histogram.bins
            }]
        });
    });
</script> -->



<script>
    // Funkcja do generowania losowych danych dla wykresu scatter
    function generateScatterData(numPoints) {
        const data = [];
        for (let i = 0; i < numPoints; i++) {
            const x_value = Math.random() * 100;
            const y_value = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
            data.push([x_value, y_value]);
        }
        return data;
    }

    // Generowanie danych dla wykresu scatter
    const numPoints = 100000; // Przykładowa liczba punktów
    const scatterData = generateScatterData(numPoints);


    

    // funkcja fetch do pobrania danych z widoku django: "get-data"
    fetch('/get-data')
        .then(response => response.json())
        .then(data => {
            console.log(data);
            createChart(data);
        });



    function createChart(scatterData) {


        // Ustalanie domyślnych wartości dla osi X i Y
        //const xMin = Math.min(...scatterData.map(d => d[0]));
        //const xMax = Math.max(...scatterData.map(d => d[0]));
        //const yMin = Math.min(...scatterData.map(d => d[1]));
        //const yMax = Math.max(...scatterData.map(d => d[1]));


        const xMin = 0;
        const xMax = 100;
        const yMin = 0;
        const yMax = 100;

        // Inicjalizacja wykresu scatter
        const chartDom = document.getElementById('scatterPlot');
        const myChart = echarts.init(chartDom);
        const option = {
            title: {
                text: 'Scatter Plot with Range Highlight'
            },
            tooltip: {},
            toolbox: {
                right: 20,
                feature: {
                    dataZoom: {}
                }
            },
            xAxis: [{}],
            yAxis: [{}],
            dataZoom: [
            {
                type: 'inside'
            },
            {
                type: 'slider',
                showDataShadow: false,
                handleIcon:
                'path://M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                handleSize: '80%'
            },
            {
                type: 'inside',
                orient: 'vertical'
            },
            {
                type: 'slider',
                orient: 'vertical',
                showDataShadow: false,
                handleIcon:
                'path://M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                handleSize: '80%'
            }
            ],
            animation: false,
            series: [
            {
                type: 'scatter',
                data: scatterData,
                symbolSize: 3,
                itemStyle: {
                    opacity: 0.4,
                    color: function (params) {
                    const xValue = params.value[0];
                    const yValue = params.value[1];
                    const inputSections = document.querySelectorAll('.inputSection');
                    for (const section of inputSections) {
                        const isActive = section.querySelector('.activeSection').checked;
                        if (!isActive) continue;
                        const minXValue = parseFloat(section.querySelector('.minXValue').value) || xMin;
                        const maxXValue = parseFloat(section.querySelector('.maxXValue').value) || xMax;
                        const minYValue = parseFloat(section.querySelector('.minYValue').value) || yMin;
                        const maxYValue = parseFloat(section.querySelector('.maxYValue').value) || yMax;
                        const highlightColor = section.querySelector('.highlightColor').value || '#FFA500';
                        if (xValue >= minXValue && xValue <= maxXValue && yValue >= minYValue && yValue <= maxYValue) {
                            return highlightColor;
                        }
                    }
                    return 'blue';
                }

                },
                blendMode: 'source-over',
                //large: true,
                largeThreshold: 500
            }
            ]
        };

        // Renderowanie wykresu scatter
        myChart.setOption(option);

    }





    // Funkcja do aktualizacji koloru punktów na wykresie
    function updateHighlight() {
        myChart.setOption({
            series: [{
                itemStyle: {
                    color: function (params) {
                        const xValue = params.value[0];
                        const yValue = params.value[1];
                        const inputSections = document.querySelectorAll('.inputSection');
                        for (const section of inputSections) {
                            const isActive = section.querySelector('.activeSection').checked;
                            if (!isActive) continue;
                            const minXValue = parseFloat(section.querySelector('.minXValue').value) || xMin;
                            const maxXValue = parseFloat(section.querySelector('.maxXValue').value) || xMax;
                            const minYValue = parseFloat(section.querySelector('.minYValue').value) || yMin;
                            const maxYValue = parseFloat(section.querySelector('.maxYValue').value) || yMax;
                            const highlightColor = section.querySelector('.highlightColor').value || '#FFA500';
                            if (xValue >= minXValue && xValue <= maxXValue && yValue >= minYValue && yValue <= maxYValue) {
                                return highlightColor;
                            }
                        }
                        return 'blue';
                    }
                }
            }]
        });
    }


    // Funkcja do dodawania nowej sekcji input
    function addInputSection() {
    const inputSections = document.getElementById('inputSections');
    const newSection = document.createElement('div');
    newSection.className = 'inputSection';
    newSection.innerHTML = `
        <div>
            <label for="minXValue">Min X Value:</label>
            <input type="number" class="minXValue" oninput="updateHighlight()">
            <label for="maxXValue">Max X Value:</label>
            <input type="number" class="maxXValue" oninput="updateHighlight()">
        </div>
        <div>
            <label for="minYValue">Min Y Value:</label>
            <input type="number" class="minYValue" oninput="updateHighlight()">
            <label for="maxYValue">Max Y Value:</label>
            <input type="number" class="maxYValue" oninput="updateHighlight()">
        </div>
        <div>
            <label for="highlightColor">Highlight Color:</label>
            <input type="color" class="highlightColor" value="#FFA500" oninput="updateHighlight()">
        </div>
        <div>
            <label for="activeSection">Active:</label>
            <input type="checkbox" class="activeSection" checked oninput="updateHighlight()">
        </div>
        <button onclick="removeInputSection(this)">Remove Section</button>
    `;
    inputSections.appendChild(newSection);
}


// Funkcja do usuwania sekcji input
function removeInputSection(button) {
    const section = button.parentElement;
    section.remove();
    updateHighlight();
}



</script>

{% endblock %}


