{% extends 'base.html' %}

{% block content %}
<!-- {% load static %} -->

<div class="App">

    <header class="App-header">
        <img src="{% static 'images/django-logo.png' %}" class="App-logo" alt="logo" />
        <h3>Welcome in Real Estate Prices Monitor Application</h3>
    </header>

    <section class="Section-Box">
        <form method="post" class="Select-Menus-Box" onchange="submit()">
            {% csrf_token %}

            <div class="Single-Select-Box">
                <h4> {{ form.city.label_tag }} </h4>
                {{ form.city }}
            </div>
            <div class="Single-Select-Box">
                <h4> {{ form.market.label_tag }} </h4>
                {{ form.market }}
            </div>
            <div class="Single-Select-Box">
                <h4> {{ form.data_type.label_tag }} </h4>
                {{ form.data_type }}
            </div>
            <!-- <button type="submit" class="btn btn-primary">Submit</button> -->
        </form>
    </section>

    
    <section class="Section-Box">
        <h4>Average Prices Trend</h4>
        <canvas id="Price-Trend-Chart" width="400" height="200"></canvas>
    </section>


    <section class="Section-Box">
        <div id="inputSections"></div>  
        <button onclick="addInputSection()" style="margin-bottom: 30px;">Add Select Section</button>

        <div id="inputExtraAxisSections"></div>  
        <button onclick="addExtraAxisSection()" style="margin-bottom: 30px;">Add Extra Axis</button>

        <div id="scatterPlot" style="width: 100%; height: 100vh;"></div>
        <!-- <div id="selectedHistogram" style="width: 100%; height: 50vh;"></div> -->
    </section>


    <section class="Section-Box">
        <h4>Average prices and informations from last scraping</h4>
        <table class='table table-striped table-bordered table-hover'>
            <thead>
                <tr>
                    <th>Pos.</th>
                    <th>Data</th>
                    <th>City</th>
                    <th>Market</th>
                    <th>Price m2</th>               
                    <th>Total price</th>
                    <th>Rooms</th>
                    <th>Area</th>
                </tr>
            </thead>
            <tbody>
                {% for offer in latest_offers %}
                    <tr>
                        <td>{{ forloop.counter }}</td>
                        <td>{{ offer.date }}</td>
                        <td>{{ offer.city_name }}</td>
                        <td>{{ offer.market_type }}</td>
                        <td>{{ offer.m2_price }}</td>
                        <td>{{ offer.total_price }}</td>
                        <td>{{ offer.rooms }}</td>
                        <td>{{ offer.area }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    </section>


</div>

<!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>

    const data = JSON.parse('{{ chart_data|safe|escapejs }}');

    let ctx = document.getElementById("Price-Trend-Chart").getContext("2d");

    let chart = new Chart(ctx, {
    type: "line",
    data: data.data,
    
    });


</script> -->


<script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.8/dist/echarts-gl.min.js"></script>

<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js"></script>




<!-- <script>
    // Funkcja do generowania losowych danych dla wykresu scatter
    function generateScatterData(numPoints) {
        const data = [];
        for (let i = 0; i < numPoints; i++) {
            const x_value = Math.random() * 100;
            const y_value = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
            data.push([x_value, y_value]);
        }
        return data;
    }

    // Funkcja do agregacji danych
    function aggregateData(data, gridSize) {
        const grid = {};
        data.forEach(point => {
            const x = Math.floor(point[0] / gridSize);
            const y = Math.floor(point[1] / gridSize);
            const key = `${x},${y}`;
            if (!grid[key]) {
                grid[key] = { count: 0, sumX: 0, sumY: 0 };
            }
            grid[key].count++;
            grid[key].sumX += point[0];
            grid[key].sumY += point[1];
        });
        const aggregatedData = [];
        for (const key in grid) {
            const cell = grid[key];
            aggregatedData.push([cell.sumX / cell.count, cell.sumY / cell.count, cell.count]);
        }
        return aggregatedData;
    }

    // Generowanie danych dla wykresu scatter
    const numPoints = 1000000; // Milion punktów
    const scatterData = generateScatterData(numPoints);

    // Agregacja danych
    const gridSize = 1; // Rozmiar komórki siatki
    const aggregatedData = aggregateData(scatterData, gridSize);

    // Inicjalizacja wykresu scatter
    const chartDom = document.getElementById('scatterPlot');
    const myChart = echarts.init(chartDom);
    const option = {
        title: {
            text: 'Aggregated Scatter Plot with 1 Million Points'
        },
        tooltip: {
            trigger: 'item',
            formatter: function (params) {
                return `X: ${params.value[0]}, Y: ${params.value[1]}, Count: ${params.value[2]}`;
            }
        },
        xAxis: {
            type: 'value',
            name: 'X Axis'
        },
        yAxis: {
            type: 'value',
            name: 'Y Axis'
        },
        series: [{
            type: 'scatter',
            symbolSize: function (val) {
                return Math.sqrt(val[2]); // Rozmiar punktu zależny od liczby punktów w komórce
            },
            data: aggregatedData,
            itemStyle: {
                color: 'blue'
            }
        }],
        dataZoom: [
            {
                type: 'inside',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'inside',
                yAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                yAxisIndex: 0,
                start: 0,
                end: 100
            }
        ],
        brush: {
            toolbox: ['rect', 'polygon', 'keep', 'clear'],
            xAxisIndex: 0,
            yAxisIndex: 0
        }
    };

    // Renderowanie wykresu scatter
    myChart.setOption(option);

    // Inicjalizacja wykresu histogram dla zaznaczonego obszaru
    const selectedChartDom = document.getElementById('selectedHistogram');
    const selectedChart = echarts.init(selectedChartDom);
    const selectedOption = {
        title: {
            text: 'Histogram of Selected Area'
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            }
        },
        xAxis: {
            type: 'category',
            name: 'Value',
            data: []
        },
        yAxis: {
            type: 'value',
            name: 'Frequency'
        },
        series: [{
            type: 'bar',
            data: []
        }]
    };

    // Renderowanie pustego wykresu histogram
    selectedChart.setOption(selectedOption);

    // Funkcja do obliczania histogramu
    function calculateHistogram(data, binCount) {
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binSize = (max - min) / binCount;
        const bins = Array(binCount).fill(0);
        data.forEach(value => {
            const binIndex = Math.min(Math.floor((value - min) / binSize), binCount - 1);
            bins[binIndex]++;
        });
        const binEdges = Array.from({ length: binCount }, (_, i) => (min + i * binSize).toFixed(2));
        return { bins, binEdges };
    }

    // Obsługa zdarzenia brushSelected
    myChart.on('brushSelected', function (params) {
        const selectedData = [];
        const mainSeries = params.batch[0].selected[0];
        for (let i = 0; i < mainSeries.dataIndex.length; i++) {
            selectedData.push(scatterData[mainSeries.dataIndex[i]][0]); // Używamy wartości X do histogramu
        }

        // Oblicz histogram
        const binCount = 20; // Liczba koszyków
        const histogram = calculateHistogram(selectedData, binCount);

        // Aktualizacja wykresu histogram
        selectedChart.setOption({
            xAxis: {
                data: histogram.binEdges
            },
            series: [{
                data: histogram.bins
            }]
        });
    });
</script> -->



<!-- <script>
    // Funkcja do generowania losowych danych dla wykresu scatter
    function generateScatterData(numPoints, startIndex = 0) {
        const data = [];
        for (let i = startIndex; i < startIndex + numPoints; i++) {
            const x_value = Math.random() * 100;
            const y_value = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
            data.push([x_value, y_value]);
        }
        return data;
    }

    // Generowanie początkowej partii danych dla wykresu scatter
    const totalPoints = 1000000; // Milion punktów
    const batchSize = 100000; // Wielkość partii
    let loadedPoints = 0;
    let scatterData = generateScatterData(batchSize, loadedPoints);
    loadedPoints += batchSize;

    // Inicjalizacja wykresu scatter
    const chartDom = document.getElementById('scatterPlot');
    const myChart = echarts.init(chartDom);
    const option = {
        title: {
            text: 'Scatter Plot with Lazy Loading'
        },
        tooltip: {
            trigger: 'item',
            formatter: function (params) {
                return `X: ${params.value[0]}, Y: ${params.value[1]}`;
            }
        },
        xAxis: {
            type: 'value',
            name: 'X Axis'
        },
        yAxis: {
            type: 'value',
            name: 'Y Axis'
        },
        series: [{
            type: 'scatter',
            symbolSize: 2,
            data: scatterData,
            itemStyle: {
                color: 'blue'
            }
        }],
        dataZoom: [
            {
                type: 'inside',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'inside',
                yAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                xAxisIndex: 0,
                start: 0,
                end: 100
            },
            {
                type: 'slider',
                yAxisIndex: 0,
                start: 0,
                end: 100
            }
        ],
        brush: {
            toolbox: ['rect', 'polygon', 'keep', 'clear'],
            xAxisIndex: 0,
            yAxisIndex: 0
        }
    };

    // Renderowanie wykresu scatter
    myChart.setOption(option);

    // Funkcja do ładowania kolejnej partii danych
    function loadMoreData() {
        if (loadedPoints < totalPoints) {
            const newData = generateScatterData(batchSize, loadedPoints);
            scatterData = scatterData.concat(newData);
            loadedPoints += batchSize;
            myChart.setOption({
                series: [{
                    data: scatterData
                }]
            });
        }
    }

    // Ładowanie kolejnych partii danych przy przewijaniu
    myChart.on('dataZoom', function () {
        loadMoreData();
    });

    // Inicjalizacja wykresu histogram dla zaznaczonego obszaru
    const selectedChartDom = document.getElementById('selectedHistogram');
    const selectedChart = echarts.init(selectedChartDom);
    const selectedOption = {
        title: {
            text: 'Histogram of Selected Area'
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                type: 'shadow'
            }
        },
        xAxis: {
            type: 'category',
            name: 'Value',
            data: []
        },
        yAxis: {
            type: 'value',
            name: 'Frequency'
        },
        series: [{
            type: 'bar',
            data: []
        }]
    };

    // Renderowanie pustego wykresu histogram
    selectedChart.setOption(selectedOption);

    // Funkcja do obliczania histogramu
    function calculateHistogram(data, binCount) {
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binSize = (max - min) / binCount;
        const bins = Array(binCount).fill(0);
        data.forEach(value => {
            const binIndex = Math.min(Math.floor((value - min) / binSize), binCount - 1);
            bins[binIndex]++;
        });
        const binEdges = Array.from({ length: binCount }, (_, i) => (min + i * binSize).toFixed(2));
        return { bins, binEdges };
    }

    // Obsługa zdarzenia brushSelected
    myChart.on('brushSelected', function (params) {
        const selectedData = [];
        const mainSeries = params.batch[0].selected[0];
        for (let i = 0; i < mainSeries.dataIndex.length; i++) {
            selectedData.push(scatterData[mainSeries.dataIndex[i]][0]); // Używamy wartości X do histogramu
        }

        // Oblicz histogram
        const binCount = 20; // Liczba koszyków
        const histogram = calculateHistogram(selectedData, binCount);

        // Aktualizacja wykresu histogram
        selectedChart.setOption({
            xAxis: {
                data: histogram.binEdges
            },
            series: [{
                data: histogram.bins
            }]
        });
    });
</script> -->



<script>
    // Funkcja do generowania losowych danych dla wykresu scatter
    function generateScatterData(numPoints) {
        const data = [];
        for (let i = 0; i < numPoints; i++) {
            const x_value = Math.random() * 100;
            const y_value = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
            data.push([x_value, y_value]);
        }
        return data;
    }
    

    // Generowanie danych dla wykresu scatter
    const numPoints = 100000; // Przykładowa liczba punktów
    //var scatterData = generateScatterData(numPoints);
    var scatterData; 
    var scatterData2; 


    var seriesArray = [];

    var legendArray = [];


    // Inicjalizacja wykresu scatter
    var chartDom = document.getElementById('scatterPlot');
    var myChart = echarts.init(chartDom);


    var xMin = 0;
    var xMax = 100;
    var yMin = 0;
    var yMax = 100;


    

    // funkcja fetch do pobrania danych z widoku django: "get-data"
    fetch('/get-data')
        .then(response => response.json())
        .then(data => {


            // // Decode the base64 encoded string
            // const compressedData = result.data;
            // const binaryString = atob(compressedData);
            // const len = binaryString.length;
            // const bytes = new Uint8Array(len);
            // for (let i = 0; i < len; i++) {
            //     bytes[i] = binaryString.charCodeAt(i);
            // }

            // // Decompress the data
            // const decompressedData = new TextDecoder('utf-8').decode(pako.inflate(bytes));
            // const data = JSON.parse(decompressedData);

            // if (!data.data1 || !data.data2) {
            //     throw new Error('Invalid data format');
            // }

            scatterData = data.data1;
            scatterData2 = data.data2;


            seriesArray.push({
                name: 'Oryginal',
                type: 'scatter',
                data: scatterData,
                symbolSize: 3,
                itemStyle: {
                    opacity: 0.4,
                },
                blendMode: 'source-over',
                //large: true,
                largeThreshold: 500
            });

            legendArray.push('Oryginal')


            //console.log(data);
            createChart(scatterData);
        });



    function createChart(scatterData) {


        // Ustalanie domyślnych wartości dla osi X i Y
        //const xMin = Math.min(...scatterData.map(d => d[0]));
        //const xMax = Math.max(...scatterData.map(d => d[0]));
        //const yMin = Math.min(...scatterData.map(d => d[1]));
        //const yMax = Math.max(...scatterData.map(d => d[1]));





        const option = {
            title: {
                text: 'Scatter Plot with Range Highlight'
            },
            tooltip: {},
            toolbox: {
                right: 20,
                feature: {
                    dataZoom: {}
                }
            },
            xAxis: [{}],
            yAxis: [{}],
            dataZoom: [
            {
                type: 'inside'
            },
            {
                type: 'slider',
                showDataShadow: false,
                handleIcon:
                'path://M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                handleSize: '80%'
            },
            {
                type: 'inside',
                orient: 'vertical'
            },
            {
                type: 'slider',
                orient: 'vertical',
                showDataShadow: false,
                handleIcon:
                'path://M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                handleSize: '80%'
            }
            ],
            animation: false,
            series: [
            {
                type: 'scatter',
                data: scatterData,
                symbolSize: 3,
                itemStyle: {
                    opacity: 0.4,
                //     color: function (params) {
                //     const xValue = params.value[0];
                //     const yValue = params.value[1];
                //     const inputSections = document.querySelectorAll('.inputSection');
                //     for (const section of inputSections) {
                //         const isActive = section.querySelector('.activeSection').checked;
                //         if (!isActive) continue;
                //         const minXValue = parseFloat(section.querySelector('.minXValue').value) || xMin;
                //         const maxXValue = parseFloat(section.querySelector('.maxXValue').value) || xMax;
                //         const minYValue = parseFloat(section.querySelector('.minYValue').value) || yMin;
                //         const maxYValue = parseFloat(section.querySelector('.maxYValue').value) || yMax;
                //         const highlightColor = section.querySelector('.highlightColor').value || '#FFA500';
                //         if (xValue >= minXValue && xValue <= maxXValue && yValue >= minYValue && yValue <= maxYValue) {
                //             return highlightColor;
                //         }
                //     }
                //     return 'blue';
                // }

                },
                blendMode: 'source-over',
                //large: true,
                largeThreshold: 500
            }
            ]
        };

        // Renderowanie wykresu scatter
        myChart.setOption(option);

    }





    // Funkcja do aktualizacji koloru punktów na wykresie
    function updateHighlight() {

        myChart.setOption({
            series: [{
                itemStyle: {
                    color: function (params) {
                        const xValue = params.value[0];
                        const yValue = params.value[1];
                        const inputSections = document.querySelectorAll('.inputSection');
                        for (const section of inputSections) {
                            const isActive = section.querySelector('.activeSection').checked;
                            if (!isActive) continue;
                            const minXValue = parseFloat(section.querySelector('.minXValue').value) || xMin;
                            const maxXValue = parseFloat(section.querySelector('.maxXValue').value) || xMax;
                            const minYValue = parseFloat(section.querySelector('.minYValue').value) || yMin;
                            const maxYValue = parseFloat(section.querySelector('.maxYValue').value) || yMax;
                            const highlightColor = section.querySelector('.highlightColor').value || '#FFA500';
                            if (xValue >= minXValue && xValue <= maxXValue && yValue >= minYValue && yValue <= maxYValue) {
                                return highlightColor;
                            }
                        }
                        return 'blue';
                    }
                }
            }]
        });
    }



    function addExtraAxis() {



        const sections = document.querySelectorAll('.inputExtraAxisSections');

        seriesArray = [];
        legendArray = [];

        seriesArray.push({
                name: 'Oryginal',
                type: 'scatter',
                data: scatterData,
                symbolSize: 3,
                itemStyle: {
                    opacity: 0.4,
                },
                blendMode: 'source-over',
                //large: true,
                largeThreshold: 500
            });

        legendArray.push('Oryginal')

        sections.forEach((section, index) => {
            const minValue = section.querySelector('.minValue').value;
            const maxValue = section.querySelector('.maxValue').value;
            const highlightColor2 = section.querySelector('.highlightColor2').value || '#FFA500';

            // Fetch data for each section
            fetch(`/extra-axis/?minValue=${minValue}&maxValue=${maxValue}`)
                .then(response => response.json())
                .then(data => {


     
                    
                    // Add new data series to the array

                    scatterData2 = data.data2;


                    seriesArray.push({
                        name: `Series ${index + 1}`,
                        type: 'scatter',
                        data: scatterData2,
                        symbolSize: 3,
                        itemStyle: {
                            opacity: 0.7,
                            color: highlightColor2
                        },
                        blendMode: 'source-over',
                        large: true,
                        largeThreshold: 500
                    });

                    legendArray.push(`Series ${index + 1}`)

                    addExtraSeries();


                })
                .catch(error => console.error('Error:', error));
        });

        



        // const maxValue = document.querySelector('.maxValue').value;
        // const minValue = document.querySelector('.minValue').value;
        // const highlightColor2 = document.querySelector('.highlightColor2').value || '#FFA500';

        // seriesArray = [];
        // seriesArray.push({
        //         name: 'Oryginal',
        //         type: 'scatter',
        //         data: scatterData,
        //         symbolSize: 3,
        //         itemStyle: {
        //             opacity: 0.4,
        //         },
        //         blendMode: 'source-over',
        //         //large: true,
        //         largeThreshold: 500
        //     });

        // legendArray.push('Oryginal')

        

        // fetch(`/extra-axis/?maxValue=${maxValue}&minValue=${minValue}`)
        //     .then(response => response.json())
        //     .then(data => {

        //         scatterData2 = data.data2;

        //         seriesArray.push({
        //             name: 'Series 2',
        //             type: 'scatter',
        //             data: scatterData2,
        //             symbolSize: 3,
        //             itemStyle: {
        //                 opacity: 0.7,
        //                 color: highlightColor2
        //             },
        //             blendMode: 'source-over',
        //             large: true,
        //             largeThreshold: 500
        //         });

        //         legendArray.push('Series 2')

        //         addExtraSeries();

        //     });
        }





    function addExtraSeries() {



        myChart.setOption({
            
            legend: {
                data: legendArray,
                textStyle: {
                    color: '#000' // Customize the legend text color if needed
                }
            },
            series: seriesArray
        });
        

    }


    // Funkcja do dodawania nowej sekcji input
    function addInputSection() {
        const inputSections = document.getElementById('inputSections');
        const newSection = document.createElement('div');
        newSection.className = 'inputSection';
        newSection.innerHTML = `
            <div>
                <label for="minXValue">Min X Value:</label>
                <input type="number" class="minXValue" oninput="updateHighlight()">
                <label for="maxXValue">Max X Value:</label>
                <input type="number" class="maxXValue" oninput="updateHighlight()">
            </div>
            <div>
                <label for="minYValue">Min Y Value:</label>
                <input type="number" class="minYValue" oninput="updateHighlight()">
                <label for="maxYValue">Max Y Value:</label>
                <input type="number" class="maxYValue" oninput="updateHighlight()">
            </div>
            <div>
                <label for="highlightColor">Highlight Color:</label>
                <input type="color" class="highlightColor" value="#FFA500" oninput="updateHighlight()">
            </div>
            <div>
                <label for="activeSection">Active:</label>
                <input type="checkbox" class="activeSection" checked oninput="updateHighlight()">
            </div>
            <button onclick="removeInputSection(this)" style="background-color: #FFCCCB;">Remove Section</button>
        `;
        inputSections.appendChild(newSection);
    }



    // Funkcja do dodawania nowej osi
    function addExtraAxisSection() {
        const inputSections = document.getElementById('inputExtraAxisSections');
        const newSection = document.createElement('div');
        newSection.className = 'inputExtraAxisSections';
        newSection.innerHTML = `
            <div>
                <label for="minValue">Min Value:</label>
                <input type="number" class="minValue" onblur="addExtraAxis()">
                <label for="maxValue">Max Value:</label>
                <input type="number" class="maxValue" onblur="addExtraAxis()">
            </div>

            <div>
                <label for="highlightColor2">Highlight Color:</label>
                <input type="color" class="highlightColor2" value="#FFA500" oninput="addExtraAxis()">
            </div>
            <div>
                <label for="activeSection2">Active:</label>
                <input type="checkbox" class="activeSection2" checked oninput="addExtraAxis()">
            </div>
            <button onclick="removeExtraAxisSection(this)" style="background-color: #FFCCCB;">Remove Axis</button>
        `;
        inputSections.appendChild(newSection);

        // Dodaj nową serię danych do wykresu
        addExtraAxis();
    }


// Funkcja do usuwania sekcji input
function removeInputSection(button) {
    const section = button.parentElement;
    section.remove();
    updateHighlight();
}


function removeExtraAxisSection(button) {
    const section = button.parentElement;
    section.remove();

    // myChart.dispose();
    // myChart = echarts.init(chartDom);

    // createChart(scatterData);

    myChart.setOption({series: []}, {replaceMerge: ['series']});

    addExtraAxis();

    updateHighlight();

}


</script>

{% endblock %}


